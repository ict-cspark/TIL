# Algorithm 강의

## 2022년 03월 23일

---

# APS 응용 - Start

## SW 문제 해결

> SW 문제 해결 역량이란 무엇인가?

+ 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력

+ 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을

  적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.

+ 문제 해결 역량은 추상적인 기술이다.

  + 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
  + 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.

+ 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

### 문제 해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 체계적인 접근을 위한 질문들

+ 비슷한 문제를 풀어본 적이 있던가?
+ 단순한 방법에서 시작할 수 있을까?
+ 문제를 단순화 할 수 있을까?
+ 그림으로 그려 볼 수 있을까?
+ 수식으로 표현 할 수 있을까?
+ 문제를 분해 할 수 있을까?
+ 뒤에서부터 생각해서 문제를 풀 수 있을까?
+ 특정 형태의 답만을 고려할 수 있을까?

## 복잡도 분석

### 알고리즘

> 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

### 알고리즘의 효율

+ 공간적 효율성
  + 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
+ 시간적 효율성
  + 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
+ 시간적 복잡도 분석
  + 하드웨어 환경에 따라 처리시간이 달라진다.
    + 보등소추 처리 프로세서 존재유무, 나눗셈 가속기능 유무
    + 입출력 장비의 성능, 공유여부
  + 소프트웨어 환경에 따라 처리시간이 달라진다.
    + 프로그램 언어의 종류
    + 운영체제, 컴파일러의 종류

+ 복잡도의 점근적 표기

  + 시간 (또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 

    이 함수는 주로 여러개의 항을 가지는 다항식이다.

  + 이를 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.
  + 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
    + O(Big-Oh) - 표기
    + Big-Omega - 표기
    + BIg-Thelta - 표기

+ O(Big-Oh)-표기

  + O-표기는 복잡도의 점근적 상한을 나타낸다.
  + 복잡도가 f(n) = 2n^2 - 7n + 4 이라면, f(n)의 O-표기는 O(n^2) 이다.
  + 단순화된 함수 n^2 에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 된다.
  + **단순히 " 실행시간이 n^2 에 비례"하는 알고리즘이라고 말함.**

+ Big-Omega-표기
  + 복잡도의 점근적 하한을 의미한다.
  + O-표기 때와 마찬가지로, 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
  + **"최소한 이만한 시간은 걸린다"**

+ Thelta-표기
  + O-표기와 오메가-표기가 같은 경우에 사용한다.
  + "f(n)은 n이 증가함에 따라 n^2과 동일한 증가율을 가진다"라는 의미이다.

### 자주 사용하는 O-표기

O(1) : 상수 시간

O(logn) : 로그(대수) 시간

O(n) : 선형 시간

O(nlogn) : 로그 선형 시간

O(n^2) : 제곱 시간

O(n^3) : 세제곱 시간

O(2^n) : 지수 시간

## 표준 입출력 방법

> Python3 표준 입출력

+ 입력
  + Raw 값의 입력 : input()
    + 받은 입력값을 문자열로 취급
  + Evaluated된 값 입력 : eval(input())
    + 받은 입력값을 평가된 데이터 형으로 취급
+ 출력
  + print()
    + 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
  + print('text', end='')
    + 출력 시 마지막에 개행문제 제외할 시
  + print('%d' % number)
    + Formatting 된 출력

+ 파일의 내용을 표준 입력으로 읽어오는 방법
  + import sys
  + sys.stdin = open("a.txt", "r")

## 비트 연산

### 비트 연산자

| 연산자 | 연산자의 기능                                                |
| ------ | ------------------------------------------------------------ |
| &      | 비트단위로 AND 연산을 한다 <br />(비트 검사, 비트 클리어 : 특정비트 0으로)<br />예) num1 & num2 |
| \|     | 비트단위로 OR 연산을 한다. <br />(비트 셋 : 특정비트 1로)<br />예) num1 \| num2 |
| ^      | 비트단위로 XOR 연산을 한다. (같으면 0 다르면 1)<br />(비트 같은지 검사, 비트 토글)<br />예) num1 ^ num2 |
| ~      | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.<br />예) ~ num |
| <<     | 피연산자의 비트 열을 왼쪽으로 이동시킨다.<br />예) num << 2  |
| >>     | 피연산자의 비트 열을 오른쪽으로 이동시킨다.<br />예) num >> 2 |

+ **1 << n**

  + 2^n 의 값을 갖는다.

  + 원소가 n개일 경우가 모든 부분집합의 수를 의미한다.

  + Power set (모든 부분 집합)

    + 공집합과 자기 자신을 포함한 모든 부분집합

    + 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든

      부분집합의 수가 계산된다.

+ **i & (1<<j)**
  + 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.

### 엔디안

+ 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는

  방법을 의미하며 HW 아키텍처마다 다르다.

+ 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변화하여 연산 할 때 올바로

  이해하지 않으면 오류를 발생 시킬 수 있다.

+ 엔디안은 크게 두가지로 나뉨

  + 빅 엔디안(Big-endian)
    + 보통 큰 단위가 앞에 나옴. 네트워크.
  + 리틀 엔디안(Little-endian)
    + 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터.

  | 종류        | 0x1234의 표현 | 0x12345678의 표현 |
  | ----------- | ------------- | ----------------- |
  | 빅 엔디안   | 12 34         | 12 34 56 78       |
  | 리틀 엔디안 | 34 12         | 78 56 34 12       |

  

## 진수

> 2진수, 8진수, 10진수, 16진수

+ 10진수 -> 타 진수로 변환
  + 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다
  + 예제) (149)10 = (10010101)2, (225)8, (95)16

+ 타 진수 -> 10진수로 변환
  + 예) (135)8 = 1*8^2 + 3*8^1 + 5*8^0 = (93)10

### 컴퓨터에서의 음의 정수 표현 방법

+ 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0로 변환한다.
  + -6 : 1000 0000 0000 0110 : 부호와 절대값 표현
  + -6 : 1111 1111 1111 1001 : 1의 보수 표현



+ **2의 보수** : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
  + -6 : 1111 1111 1111 1010 : 2의 보수 표현
