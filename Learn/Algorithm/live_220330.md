# Algorithm 강의

## 2022년 03월 30일

---

# APS 응용 - 분할 정복 & 백트래킹

## 분할 정복 기법

### 설계 전략

+ 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
+ 정복 : 나눈 작은 문제를 각각 해결한다.
+ 통합 : (필요하다면) 해결된 해답을 모은다.

### 병합 정렬

+ 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
+ 분할 정복 알고리즘 활용
  + 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄.
  + top-down 방식
+ 시간 복잡도
  + O(n long n)

+ 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
+ 부분집합이 1개로 병합될 때까지 반복함

### 퀵 정렬

+ 주어진 배열과 두 개로 분할하고, 각각을 정렬한다.

+ 병합 정렬은 그냥 두 부분으로 나누는 반면에, 퀵 정렬은 분할할 때,

  기준 아이템(pivot item) 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.

+ 각 부분 정렬이 끝난 후, 병합정렬은 '병합'이란 후처리 작업이 필요하나,

  퀵 정렬은 필요로 하지 않는다.

> **아이디어**

+ P(피봇) 값들 보다 큰 값은 오른쪽, 작은 값들은 왼쪽 집합에 위치하도록 한다.
+ 피봇을 두 집합의 가운데이 위치시킨다.

> **피봇 선택**

+ 왼쪽 끝 / 오른쪽 끝 / 임의의 세개 값 중에 중간 값

### 이진 검색

+ 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고

  검색을 계속 진행하는 방법

  + 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를

    반으로 줄여가면서 보다 빠르게 검색을 수행함

+ 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

+ **검색 과정**

  + 자료의 중앙에 있는 원소를 고른다

  + 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.

  + 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서

    새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.

  + 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복한다.

#### 분할 정복의 활용

+ 병합 정렬은 외부 정렬의 기본이 되는 정렬 알고리즘이다. 또한, 멀티코어 CPU나 다수의

  프로세서에서 정렬 알고리즘을 병렬화하기 위해 병합 정렬 알고리즘이 활용한다.

+ 퀵 정렬은 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘이다.

## 백트래킹

+ 여러 가지 선택지(옵션)들이 존재하는 상황에서 한가지를 선택한다.
+ 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
+ 이런 선택을 반복하면서 최종 상태에 도달한다.
  + 올바른 선택을 계속하면 목표 상태(goal state)에 도달한다.

### 백트래킹 개념

> 백트래킹과 깊이 우선 탐색과의 차이

+ 어떤 노드에서 출발하는 경로가 해결척으로 이어질 것 같지 않으면 더 이상 그 경로를

  따라가지 않음으로써 시도의 횟수를 줄임. (Prunning 가지치기) 

+ 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단

+ 깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많음. 즉 N! 가지의 경우의 수를 가진

  문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제.

+ 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 

  경우에는 여전히 지수함수 시간을 요하므로 처리 불가능

#### 백트래킹 기법

+ 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면

  그 노드의 부모로 되돌아가 (backtracking) 다음 자식 노드로 감.

+ 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는

  유망하지 않다고 하며, 반대로 해댭의 가능성이 있으면 유망하다고 한다.

+ 가지치기(pruning) : 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.

#### 백트래킹 절차

1. 상태 공간 트리의 깊이 우선 검색을 실시한다.

2. 각 노드가 유망한지를 점검한다.
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

##  트리

> 트리는 싸이클이 없는 무향 연결 그래프이다.

+ 두 노드(or 정점) 사이에는 유일한 경로가 존재한다.
+ 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.

+ 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.

> 비선형 구조

+ 원소들 간에 1:n 관계를 가지는 자료구조
+ 우너소들 간에 계층관계를 가지는 계층형 자료구조

> 한개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.

+ 노드 중 부모가 없는 노드를 루트(root)라 한다.
+ 나머지 노드들은 n(>=0) 개의 분리 집합 T1, --- . TN으로 분리될 수 있다.

> 이들 T1, --- . TN은 각각 하나의 트리가 되며 (재귀적 정의) 루트의 서브 트리라 한다.

+ 노드(node) : 트리의 원소이고 정점이라고도 한다.

+ 간선(edge) : 노드를 연결하는 선
  + 부모 노드와 자식 노드를 연결
+ 루트 노드 : 트리의 시작 노드

### 이진 트리

+ 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리
+ 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
  + 왼쪽 자기 노드
  + 오른쪽 자식 노드

+ 레벨 i에서의 노드의 최대 개수는 2^i 개

+ 높이가 h 인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며,

  최대 개수는 (2^(h+1) -1) 개가 된다.

#### 포화 이진 트리

+ 모든 레벨에 노드가 포화상태로 채워져 있는 이진 트리

#### 완전 이진 트리

+ 높이가 h이가 노드 수가 n개일 때. 포화 이진 트리의 노드 번호 1번부터

​		n번까지 빈자리가 없는 이진 트리

#### 편향 이진 트리

+ 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
  + 왼쪽 편향 이진 트리
  + 오른쪽 편향 이진 트리

#### 순회

+ 순회란 트리의 각 노드를 중복되지 않게 전부 방문 하는 것을 말하는데

  트리는 비 선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 있다.

> 3가지의 기본적인 순회방법

+ 전위 순회 : VLR
  + 자손 노드보다 현재 노드를 먼저 방문한다.
+ 중위 순회 : LVR
  + 왼쪽 자손 노드, 현재 노드, 오른쪽 자손 노드 순으로 방문한다.
+ 후위 순회 : LRV
  + 현재 노드보다 자손 노드를 먼저 방문한다.

### 연결리스트

+ 배열을 이용한 이진 트리의 표현의 단점을 보완하기 위해 연결리스트를 이용하여

  트리를 표현할 수 있다.

### 힙

> 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은
>
> 노드를 찾기 위해서 만든 자료구조

+ 최대 힙 (max heap)
  + 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  + 부모 노드의 키 값 > 자식 노드의 키 값
  + 루트 노드 : 키 값이 가장 큰 노드
+ 최소 힙 (min heap)
  + 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  + 부모 노드의 키 값 < 자식 노드의 키 값
  + 루트 노드 : 키 값이  가장 작은 노드
+ 힙에서는 루트 노드의 원소만을 삭제 할 수 있다.
+ 루트 노드의 원소를 삭제하여 반환한다.
+ 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.
  + 우선순위 큐와 비교
